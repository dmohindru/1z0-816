REVIEWING MODULE DIRECTIVES
---------------------------

Common module directives
Derivative				Description
---------------------------------------------------------------------------------------------------------------------------------------
exports <package>			Allows all modules to access the package
exports <package> to <module>		Allows a specific module to access the package
requires <module>			Indicates module is dependent on another module
requires transitive <module>		Indicates the module and that all modules that use this module are dependent on another module
uses <interface>			Indicates that a module uses a service
provides <interface> with <class>	Indicates that a module provides an implementation of a service

COMPARING TYPES OF MODULES
--------------------------

Types of Modules
1. Named Modules
2. Automatic Modules
3. Unnamed Modules

Named Modules
A named module is one containing a module-info file. To review, this file appears in the root of the JAR alongside one or more packages. Unless otherwise specified, a module is a named module. Named modules appear on the module path rather than the classpath.

Automatic Modules
An automatic module appears on the module path but does not contain a module-info file. It is simply a regular JAR file that is placed on the module path and gets treated as a module. The code referencing an automatic module treats it as if there is a module-info file present. It automatically exports all packages. It also determines the module name. When Java 9 was released, authors of Java libraries were encouraged to declare the name they intended to use for the module in the future. All they had to do was set a property called Automatic-Module-Name in the MANIFEST.MF file.

If the JAR file does not specify an automatic module name, Java will still allow you to use it in the module path. In this case, Java will determine the module name for you. 

Let's review the algorithm in a list for determining the name of an automatic module.

If the MANIFEST.MF specifies an Automatic-Module-Name, use that. Otherwise, proceed with the remaining rules.
1. Remove the file extension from the JAR name.
2. Remove any version information from the end of the name. A version is digits and dots with possible extra information at the end, for example, -1.0.0 or -1.0-RC.
3. Replace any remaining characters other than letters and numbers with dots.
4. Replace any sequences of dots with a single dot.
5. Remove the dot if it is the first or last character of the result.

Practicing with automatic module names
#	Description				Example 1				Example 2
-----------------------------------------------------------------------------------------------------------
1	Beginning JAR name			commons2-x-1.0.0-SNAPSHOT.jar		mod_$-1.0.jar
2	Remove file extension			commons2-x-1.0.0-SNAPSHOT		mod_$-1.0
3	Remove version information		commons2-x				mod_$
4	Replace special characters		commons2.x				mod..
5	Replace sequence of dots		commons2.x				mod.
6	Remove leading/trailing dots 
(results in the automatic module name)	commons2.x				mod

Unnamed Modules
An unnamed module appears on the classpath. Like an automatic module, it is a regular JAR. Unlike an automatic module, it is on the classpath rather than the module path. 
This means an unnamed module is treated like old code and a second-class citizen to modules. An unnamed module does not usually contain a module-info file. If it happens to contain one, that file will be ignored since it is on the classpath. 
Unnamed modules do not export any packages to named or automatic modules. The unnamed module can read from any JARs on the classpath or module path.

Properties of modules types
Property								Named				Automatic			Unnamed
-------------------------------------------------------------------------------------------------------------------------------------------------------
A_____module contains a module-info file?				Yes				No				Ignored if present
A_____module exports which packages to other modules?		Those in the module-info file	All packages			No packages
A_____module is readable by other modules on the module path?	Yes				Yes				No
A_____module is readable by other JARs on the classpath?		Yes				Yes				Yes


ANALYZING JDK DEPENDENCIES
--------------------------
Identifying Built-in Modules
Prior to Java 9, developers could use any package in the JDK by merely importing it into the application. This meant the whole JDK had to be available at runtime because a program could potentially need anything. With modules, your application specifies which parts of the JDK it uses. This allows the application to run on a full JDK or a subset.

The most important module to know is java.base. It contains most of the packages you have been learning about for the exam. In fact, it is so important that you don't even have to use the requires directive; it is available to all modular applications.

Common modules
Module name	What it contains					Coverage in book
------------------------------------------------------------------------------------------------------------
java.base	Collections, Math, IO, NIO.2, Concurrency, etc.	Most of this book
java.desktop	Abstract Windows Toolkit (AWT) and Swing		Not on the exam beyond the module name
java.logging	Logging						Not on the exam beyond the module name
java.sql	JDBC							Chapter 10, “JDBC”
java.xml	Extensible Markup Language (XML)			Not on the exam beyond the module name

For the exam, you need to know that module names begin with java for APIs you are likely to use and with jdk for APIs that are specific to the JDK.
Java modules prefixed with java
java.base		java.naming		java.smartcardio
java.compiler		java.net .http		java.sql
java.datatransfer	java.prefs		java.sql.rowset
java.desktop		java.rmi		java.transaction.xa
java.instrument	java.scripting		java.xml
java.logging		java.se		java.xml.crypto
java.management	java.security.jgss	
java.management.rmi	java.security.sasl	

Table below lists all the modules that begin with jdk. We recommend reviewing this right before the exam to increase the chances of them sounding familiar.
Java modules prefixed with jdk
jdk.accessiblity		jdk.jconsole		jdk.naming.dns
jdk.attach			jdk.jdeps		jdk.naming.rmi
jdk.charsets			jdk.jdi		jdk.net
jdk.compiler			jdk.jdwp.agent		jdk.pack
jdk.crypto.cryptoki		jdk.jfr		jdk.rmic
jdk.crypto.ec			jdk.jlink		jdk.scripting.nashorn
jdk.dynalink			jdk.jshell		jdk.sctp
jdk.editpad			jdk.jsobject		jdk.security.auth
jdk.hotspot.agent		jdk.jstatd		jdk.security.jgss
jdk.httpserver			jdk.localdata		jdk.xml.dom
jdk.jartool			jdk.management		jdk.zipfs
jdk.javadoc			jdk.management.agent	
jdk.jcmd			jdk.management.jfr	

The jdeps command gives you information about dependencies. Luckily, you are not expected to memorize all the options for the 1Z0-816 exam.

Below command prints dependies of zoo.dino.jar file
# jdeps zoo.dino.jar 

Below command prints dependies of zoo.dino.jar file in summary mode
# jdeps -s zoo.dino.jar

The jdeps command has an option to provide details about these unsupported APIs. 
# jdeps --jdk-internals zoo.dino.jar 


MIGRATING AN APPLICATION
------------------------

