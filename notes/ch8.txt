UNDERSTANDING FILES AND DIRECTORIES
------------------------------------

A file is a record within the storage device that holds data. Files are organized into hierarchies using directories. A directory is a location that can contain files as well as other directories. When working with directories in Java, we often treat them like files. In fact, we use many of the same classes to operate on files and directories. For example, a file and directory both can be renamed with the same Java method.

For the exam, you just need to know how to issue commands using the Java APIs. The JVM will automatically connect to the local file system, allowing you to perform the same operations across multiple platforms.

Finally, a path is a String representation of a file or directory within a file system. Each file system defines its own path separator character that is used between directory entries. 

Data is stored in a file system (and memory) as a 0 or 1, called a bit. Since it's really hard for humans to read/write data that is just 0s and 1s, they are grouped into a set of 8 bits, called a byte.

The File class is used to read information about existing files and directories, list the contents of a directory, and create/delete files and directories.

An instance of a File class represents the path to a particular file or directory on the file system. The File class cannot read or write data within a file, although it can be passed as a reference to many stream classes to read or write data, as you will see in the next section.

A File object often is initialized with a String containing either an absolute or relative path to the file or directory within the file system.

many programming languages and file systems support both types of slashes when writing path statements. For convenience, Java offers two options to retrieve the local separator character: a system property and a static variable defined in the File class.

System.out.println(System.getProperty("file.separator"));
System.out.println(java.io.File.separator);

There are three File constructors you should know for the exam.

public File(String pathname)
public File(File parent, String child)
public File(String parent, String child)

If the parent instance is null, then it would be skipped, and the method would revert to the single String constructor.

If you try to operate on a file that does not exist or you do not have access to, some File methods will throw an exception.

Commonly used java.io.File methods

Method Name			Description
----------------------------------------------------------------------------------------------------------------------------------------------------------
boolean delete()		Deletes the file or directory and returns true only if successful. If this instance denotes a directory, then the directory 				must be empty in order to be deleted.
boolean exists()		Checks if a file exists
String getAbsolutePath()	Retrieves the absolute name of the file or directory within the file system
String getName()		Retrieves the name of the file or directory.
String getParent()		Retrieves the parent directory that the path is contained in or null if there is none
boolean isDirectory()		Checks if a File reference is a directory within the file system
boolean isFile()		Checks if a File reference is a file within the file system
long lastModified()		Returns the number of milliseconds since the epoch (number of milliseconds since 12 a.m. UTC on January 1, 1970) when the file 					was last modified
long length()			Retrieves the number of bytes in the file
File[] listFiles()		Retrieves a list of files within a directory
boolean mkdir()		Creates the directory named by this path
boolean mkdirs()		Creates the directory named by this path including any nonexistent parent directories
boolean renameTo(File dest)	Renames the file or directory denoted by this path to dest and returns true only if successful

On the exam, you might get paths that look like files but are directories, or vice versa. For example, /data/zoo.txt could be a file or a directory, even though it has a file extension. Don't assume it is either unless the question tells you it is!


INTRODUCING I/O STREAMS
-----------------------

The contents of a file may be accessed or written via a stream, which is a list of data elements presented sequentially. Streams should be conceptually thought of as a long, nearly never-ending “stream of water” with data presented one “wave” at a time.

Even if you come across a particular stream on the exam that you do not recognize, often the name of the stream gives you enough information to understand exactly what it does.

The java.io API defines two sets of stream classes for reading and writing streams: byte streams and character streams.

Differences between Byte and Character Streams
1. Byte streams read/write binary data (0s and 1s) and have class names that end in InputStream or OutputStream.
2. Character streams read/write text data and have class names that end in Reader or Writer.

The API frequently includes similar classes for both byte and character streams, such as FileInputStream and FileReader. The difference between the two classes is based on how the bytes of the stream are read or written.

The byte streams are primarily used to work with binary data, such as an image or executable file, while character streams are used to work with text files.

For the exam, you don't need to memorize the character encodings, but you should be familiar with the names if you come across them on the exam.

In Java, the character encoding can be specified using the Charset class by passing a name value to the static Charset.forName() method, such as in the following examples:

Charset usAsciiCharset = Charset.forName("US-ASCII");
Charset utf8Charset = Charset.forName("UTF-8");
Charset utf16Charset = Charset.forName("UTF-16");

For character encoding, just remember that using a character stream is better for working with text data than a byte stream.

Input vs. Output Streams
Most InputStream stream classes have a corresponding OutputStream class, and vice versa. For example, the FileOutputStream class writes data that can be read by a FileInputStream.

There are exceptions to this rule. For the exam, you should know that PrintWriter has no accompanying PrintReader class. Likewise, the PrintStream is an OutputStream that has no corresponding InputStream class.

Low-Level vs. High-Level Streams
Another way that you can familiarize yourself with the java.io API is by segmenting streams into low-level and high-level streams.

A low-level stream connects directly with the source of the data, such as a file, an array, or a String. Low-level streams process the raw data or resource and are accessed in a direct and unfiltered manner. For example, a FileInputStream is a class that reads file data one byte at a time.

Alternatively, a high-level stream is built on top of another stream using wrapping. Wrapping is the process by which an instance is passed to the constructor of another class, and operations on the resulting instance are filtered and applied to the original instance. For example, take a look at the FileReader and BufferedReader objects in the following sample code:

try (var br = new BufferedReader(new FileReader("zoo-data.txt"))) {
   System.out.println(br.readLine());
}

High-level streams can take other high-level streams as input. For example, although the following code might seem a little odd at first, the style of wrapping a stream is quite common in practice:

try (var ois = new ObjectInputStream(
      new BufferedInputStream(
         new FileInputStream("zoo-data.txt")))) {
   System.out.print(ois.readObject());
}

For the exam, the only low-level stream classes you need to be familiar with are the ones that operate on files. The rest of the nonabstract stream classes are all high-level streams.

The java.io library defines four abstract classes that are the parents of all stream classes defined within the API: InputStream, OutputStream, Reader, and Writer.

The constructors of high-level streams often take a reference to the abstract class. For example, BufferedWriter takes a Writer object as input, which allows it to take any subclass of Writer.

One common area where the exam likes to play tricks on you is mixing and matching stream classes that are not compatible with each other. For example, take a look at each of the following examples and see whether you can determine why they do not compile:
new BufferedInputStream(new FileReader("z.txt"));  // DOES NOT COMPILE
new BufferedWriter(new FileOutputStream("z.txt")); // DOES NOT COMPILE
new ObjectInputStream(
   new FileOutputStream("z.txt"));                 // DOES NOT COMPILE
new BufferedInputStream(new InputStream());        // DOES NOT COMPILE

Review of java.io Class Name Properties
1. A class with the word InputStream or OutputStream in its name is used for reading or writing binary or byte data, respectively.
2. A class with the word Reader or Writer in its name is used for reading or writing character or string data, respectively.
3. Most, but not all, input classes have a corresponding output class.
4. A low-level stream connects directly with the source of the data.
5. A high-level stream is built on top of another stream using wrapping.
6. A class with Buffered in its name reads or writes data in groups of bytes or characters and often improves performance in sequential file systems.
7. With a few exceptions, you only wrap a stream with another stream if they share the same abstract parent.

The java.io abstract stream base classes
Class Name		Description
------------------------------------------------------------------------
InputStream		Abstract class for all input byte streams
OutputStream		Abstract class for all output byte streams
Reader			Abstract class for all input character streams
Writer			Abstract class for all output character streams

The java.io concrete stream classes

Class Name		Low/High Level		Description
---------------------------------------------------------------------------------------------------------------------------------------------------------
FileInputStream	Low			Reads file data as bytes
FileOutputStream	Low			Writes file data as bytes
FileReader		Low			Reads file data as characters
FileWriter		Low			Writes file data as characters
BufferedInputStream	High			Reads byte data from an existing InputStream in a buffered manner, which improves efficiency and performance
BufferedOutputStream	High			Writes byte data to an existing OutputStream in a buffered manner, which improves efficiency and performance
BufferedReader		High			Reads character data from an existing Reader in a buffered manner, which improves efficiency and performance
BufferedWriter		High			Writes character data to an existing Writer in a buffered manner, which improves efficiency and performance
ObjectInputStream	High			Deserializes primitive Java data types and graphs of Java objects from an existing InputStream
ObjectOutputStream	High			Serializes primitive Java data types and graphs of Java objects to an existing OutputStream
PrintStream		High			Writes formatted representations of Java objects to a binary stream
PrintWriter		High			Writes formatted representations of Java objects to a character stream

COMMON I/O STREAM OPERATIONS
-----------------------------

Both InputStream and Reader declare the following method to read byte data from a stream:
// InputStream and Reader
public int read() throws IOException

Likewise, OutputStream and Writer both define the following method to write a byte to the stream:
// OutputStream and Writer
public void write(int b) throws IOException

Note: Other stream classes you will learn about in this chapter throw exceptions to denote the end of the stream rather than a special value like -1.

Note: Most I/O stream methods declare a checked IOException. File or network resources that a stream relies on can disappear at any time, and our programs need be able to readily adapt to these outages.

The byte stream classes also include overloaded methods for reading and writing multiple bytes at a time.
// InputStream
public int read(byte[] b) throws IOException
public int read(byte[] b, int offset, int length) throws IOException
// OutputStream
public void write(byte[] b) throws IOException
public void write(byte[] b, int offset, int length) throws IOException

The offset and length are applied to the array itself. For example, an offset of 5 and length of 3 indicates that the stream should read up to 3 bytes of data and put them into the array starting with position 5.

There are equivalent methods for the character stream classes that use char instead of byte.
// Reader
public int read(char[] c) throws IOException
public int read(char[] c, int offset, int length) throws IOException
 
// Writer
public void write(char[] c) throws IOException
public void write(char[] c, int offset, int length) throws IOException

All I/O streams include a method to release any resources within the stream when it is no longer needed.
// All I/O stream classes
public void close() throws IOException

Since all I/O streams implement Closeable, the best way to do this is with a try-with-resources statement.
try (var fis = new FileInputStream("zoo-data.txt")) {
   System.out.print(fis.read());
}

What about if you need to pass a stream to a method? That's fine, but the stream should be closed in the method that created it.
public void printData(InputStream is) throws IOException {
   int b;
   while ((b = is.read()) != -1) {
      System.out.print(b);
   }
}
 public void readFile(String fileName) throws IOException {
   try (var fis = new FileInputStream(fileName)) {
      printData(fis);
   }
}

When working with a wrapped stream, you only need to use close() on the topmost object. Doing so will close the underlying streams. 
Unnecessary thre close method calls are made
try (var fis = new FileOutputStream("zoo-banner.txt"); // Unnecessary
         var bis = new BufferedOutputStream(fis);
         var ois = new ObjectOutputStream(bis)) {
       ois.writeObject("Hello");
    }
Instead below code in more preferred one
try (var ois = new ObjectOutputStream(
          new BufferedOutputStream(
             new FileOutputStream("zoo-banner.txt")))) {
       ois.writeObject("Hello");
    }


All input stream classes include the following methods to manipulate the order in which data is read from a stream:

// InputStream and Reader
public boolean markSupported() // Return true only if mark() is supported
public void void mark(int readLimit) // Return stream to earlier position
public void reset() throws IOException // Return stream to earlier/initial position
public long skip(long n) throws IOException // Read data from stream and skip it

Tip: Not all input stream classes support mark() and reset(). Make sure to call markSupported() on the stream before calling these methods or an exception will be thrown at runtime.

The return parameter of skip() tells us how many values were actually skipped. For example, if we are near the end of the stream and call skip(1000), the return value might be 20, indicating the end of the stream was reached after 20 values were skipped.

When data is written to an output stream, the underlying operating system does not guarantee that the data will make it to the file system immediately. If the data is cached in memory and the application terminates unexpectedly, the data would be lost, because it was never written to the file system. To address this, all output stream classes provide a flush() method, which requests that all accumulated data be written immediately to disk.
// OutputStream and Writer
public void flush() throws IOException

Common I/O stream methods
Stream Class		Method Name			Description
-----------------------------------------------------------------------------------------------------------------------------------------------------------
All streams		void close()			Closes stream and releases resources
All input streams	int read()			Reads a single byte or returns -1 if no bytes were available
InputStream		int read(byte[] b)	
Reader			int read(char[] c)		Reads values into a buffer. Returns number of bytes read

InputStream		int read(byte[] b, 
			int offset, 
			int length)	
Reader			int read(char[] c, 
			int offset, 
			int length)			Reads up to length values into a buffer starting from position offset. Returns number of bytes read

All output streams	void write(int)		Writes a single byte
OutputStream		void write(byte[] b)	
Writer			void write(char[] c)		Writes an array of values into the stream
OutputStream		void write(byte[] b, 
			int offset, 
			int length)	
Writer			void write(char[] c, 
			int offset, 
			int length)			Writes length values from an array into the stream, starting with an offset index
			
All input streams	boolean markSupported()	Returns true if the stream class supports mark()
All input streams	mark(int readLimit)		Marks the current position in the stream
All input streams	void reset()			Attempts to reset the stream to the mark() position
All input streams	long skip(long n)		Reads and discards a specified number of characters
All output streams	void flush()			Flushes buffered data through the stream

WORKING WITH I/O STREAM CLASSES
-------------------------------

